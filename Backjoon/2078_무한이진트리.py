# 수학


# 문제: https://www.acmicpc.net/problem/2078

# 나중에 다시 풀어볼만한 문제
# 메모리: 32412KB / 시간: 40ms
from sys import stdin


input = stdin.readline

def main():
    """
    왼쪽 자식: (A+B, B)
    오른쪽 자식: (A, A+B)

    🗝️부모로 거슬러 올라가는 방식을 생각해봐야함.
    예를들어 (A, B)에서,
    - A > B이면 왼쪽에서 온 것이므로 부모 = (A-B, B), L += 1
    - B > A이면 오른쪽에서 온 것이므로 부모 = (A, B-A), R += 1
    위 과정을 반복하다 (0, 1)또는 (1, 0)이 되는 순간 종료한다.

    그리고 이건 유클리드 호제법과 동일한 구조를 가지게 됨.
    - 유클리드 호제법은 gcd(a,b)를 구할 때 큰 수에서 작은 수를 반복해서 빼는 알고리즘.
    - (A,B)에서 (1,1)로 올라가는 과정은 "큰 수에서 작은 수를 빼면서 부모를 찾는 과정"과 같음.

    ⭐조합하면, 매번 1씩 빼는 대신 "큰 수 // 작은 수"를 구하는 방식으로 풀 수 있음.
    - ex) (19, 5)
        - 19 // 5 = 3 → 왼쪽 이동 3회 한꺼번에 누적 → 부모 = (19%5,5) = (4,5)
        - 5 // 4 = 1 → 오른쪽 이동 1회 → 부모 = (4,1)
        - 4 // 1 = 4 → 왼쪽 이동 4회 → 부모 = (0,1) → 사실상 (1,1)
    
    그리고 문제에서 정의한 부모 노드는 (1, 1)이므로,
    계산 후 왼쪽(A)가 0이라면 left 카운트를 -1, 오른쪽(B)가 0이라면 right 카운트를 -1 처리한다.
    """
    A, B = map(int, input().split())

    left = right = 0

    while A and B:
        if A > B:
            left += A // B
            A %= B
        else:
            right += B // A
            B %= A
        
    if A == 0:
        left -= 1
    else:
        right -= 1
        
    print(left, right)


main()